# IntelliHub 后端技术实现文档

> **版本**：v1.0  
> **更新日期**：2024-01-15  
> **技术栈**：Java 8 + Spring Boot 2.x + Spring Cloud



| 用户名 | 密码     | 角色       |
| :----- | :------- | :--------- |
| admin  | admin123 | 平台管理员 |
| demo   | admin123 | API开发者  |

---

## 一、整体架构设计

### 1.1 架构概览

采用**微服务架构**，基于 Spring Cloud 生态构建，实现服务解耦、独立部署、弹性扩展。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              前端应用层                                       │
│                    Vue 3 + Element Plus + Vite                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Nginx / 负载均衡                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    ▼                                   ▼
┌───────────────────────────────┐     ┌───────────────────────────────────────┐
│      API Gateway (网关)        │     │         管理后台 API                   │
│   intellihub-gateway          │     │    intellihub-admin-api               │
│   - 统一鉴权                   │     │    - 控制台接口                        │
│   - 流量控制                   │     │    - 管理功能                          │
│   - 请求路由                   │     └───────────────────────────────────────┘
│   - 日志采集                   │                       │
└───────────────────────────────┘                       │
              │                                         │
              ▼                                         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           微服务层 (Spring Cloud)                            │
├─────────────────┬─────────────────┬─────────────────┬───────────────────────┤
│  IAM Service    │  API Service    │ Gateway Service │   Monitor Service     │
│  身份认证服务    │  API管理服务     │  网关配置服务    │   监控统计服务         │
│                 │                 │                 │                       │
│ - 用户管理      │ - API生命周期   │ - 路由配置      │ - 调用统计            │
│ - 租户管理      │ - API文档       │ - 限流策略      │ - 日志分析            │
│ - 权限管理      │ - 版本管理      │ - 鉴权策略      │ - 告警管理            │
│ - Token签发     │ - 分组管理      │ - 插件管理      │ - SLA计算             │
└─────────────────┴─────────────────┴─────────────────┴───────────────────────┘
              │                 │                 │                 │
              └─────────────────┴─────────────────┴─────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              基础设施层                                       │
├─────────────────┬─────────────────┬─────────────────┬───────────────────────┤
│     MySQL       │     Redis       │   Elasticsearch │      Kafka            │
│   主数据存储     │   缓存/会话      │    日志/搜索     │    消息队列           │
└─────────────────┴─────────────────┴─────────────────┴───────────────────────┘
```

### 1.2 微服务划分

| 服务名称 | 端口 | 职责描述 | 核心功能 |
|---------|------|---------|---------|
| **intellihub-gateway** | 8080 | API网关 | 统一入口、鉴权、限流、路由转发 |
| **intellihub-admin-api** | 8081 | 管理后台API | 前端控制台接口聚合 |
| **intellihub-iam** | 8082 | 身份认证服务 | 用户、租户、权限、Token |
| **intellihub-api-service** | 8083 | API管理服务 | API定义、发布、文档、版本 |
| **intellihub-gateway-service** | 8084 | 网关配置服务 | 路由、限流、插件配置 |
| **intellihub-monitor** | 8085 | 监控统计服务 | 调用统计、日志、告警 |
| **intellihub-common** | - | 公共模块 | 工具类、通用实体、常量 |

### 1.3 项目模块结构

```
intellihub-backend/
├── intellihub-parent/                 # 父POM，统一依赖版本管理
│   └── pom.xml
├── intellihub-common/                 # 公共模块
│   ├── intellihub-common-core/        # 核心工具类
│   ├── intellihub-common-redis/       # Redis封装
│   ├── intellihub-common-mybatis/     # MyBatis封装
│   ├── intellihub-common-security/    # 安全模块
│   └── intellihub-common-log/         # 日志模块
├── intellihub-gateway/                # API网关
├── intellihub-admin-api/              # 管理后台API
├── intellihub-iam/                    # 身份认证服务
│   ├── intellihub-iam-api/            # 对外API接口
│   └── intellihub-iam-biz/            # 业务实现
├── intellihub-api-service/            # API管理服务
│   ├── intellihub-api-api/
│   └── intellihub-api-biz/
├── intellihub-gateway-service/        # 网关配置服务
│   ├── intellihub-gateway-api/
│   └── intellihub-gateway-biz/
└── intellihub-monitor/                # 监控统计服务
    ├── intellihub-monitor-api/
    └── intellihub-monitor-biz/
```

---

## 二、技术选型

### 2.1 核心框架

| 技术 | 版本 | 用途 |
|-----|------|-----|
| **JDK** | 1.8 | 运行环境 |
| **Spring Boot** | 2.7.x | 基础框架 |
| **Spring Cloud** | 2021.0.x | 微服务框架 |
| **Spring Cloud Gateway** | 3.1.x | API网关 |
| **Spring Security** | 5.7.x | 安全框架 |
| **MyBatis-Plus** | 3.5.x | ORM框架 |
| **Nacos** | 2.2.x | 注册中心 + 配置中心 |
| **OpenFeign** | 3.1.x | 服务间调用 |
| **Sentinel** | 1.8.x | 流量控制、熔断降级 |

### 2.2 中间件

| 中间件 | 版本 | 用途 |
|-------|------|-----|
| **MySQL** | 8.0 | 主数据存储 |
| **Redis** | 6.x | 缓存、分布式锁、Token存储 |
| **Elasticsearch** | 7.x | 日志存储、全文搜索 |
| **Kafka** | 2.8.x | 异步消息、事件驱动 |
| **MinIO** | - | 文件存储（可选） |

### 2.3 开发工具

| 工具 | 用途 |
|-----|------|
| **Maven** | 项目构建 |
| **Lombok** | 简化代码 |
| **MapStruct** | 对象映射 |
| **Swagger/Knife4j** | API文档 |
| **Hutool** | 工具库 |

---

## 三、核心流程设计

### 3.1 API发布流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           API 发布流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│  创建API  │───▶│ 配置参数  │───▶│  保存草稿 │───▶│  发布API  │───▶│ 网关生效  │
│  (草稿)   │    │          │    │          │    │          │    │          │
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
     │               │               │               │               │
     ▼               ▼               ▼               ▼               ▼
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│API Service│   │API Service│   │  MySQL   │    │API Service│   │Gateway   │
│创建API记录│   │参数校验   │    │持久化存储│    │状态变更   │    │Service   │
│状态:DRAFT│    │元数据存储 │    │          │    │PUBLISHED │    │路由同步  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
                                                     │
                                                     ▼
                                              ┌──────────┐
                                              │  Kafka   │
                                              │发布事件  │
                                              │API_PUBLISH│
                                              └──────────┘
                                                     │
                                    ┌────────────────┼────────────────┐
                                    ▼                ▼                ▼
                              ┌──────────┐    ┌──────────┐    ┌──────────┐
                              │ Gateway  │    │ Monitor  │    │  其他    │
                              │ 更新路由  │    │ 初始化   │    │ 消费者   │
                              │ 配置     │    │ 统计数据  │    │          │
                              └──────────┘    └──────────┘    └──────────┘
```

#### 3.1.1 发布流程详细步骤

**Step 1: 创建API（草稿状态）**
```java
// API Service
POST /api/v1/apis
{
    "name": "用户登录认证",
    "groupId": "user-service",
    "method": "POST",
    "path": "/api/v1/auth/login",
    "description": "用户登录认证接口",
    "backendService": "user-service",
    "backendPath": "/internal/auth/login"
}

// 返回
{
    "code": 0,
    "data": {
        "id": "api_123456",
        "status": "DRAFT",
        "version": "v1.0"
    }
}
```

**Step 2: 配置API参数**
```java
// 配置请求参数
PUT /api/v1/apis/{apiId}/params
{
    "queryParams": [...],
    "headerParams": [...],
    "bodySchema": {...}
}

// 配置安全策略
PUT /api/v1/apis/{apiId}/security
{
    "authMethods": ["JWT", "APP_KEY"],
    "rateLimit": {
        "enabled": true,
        "limit": 100,
        "unit": "SECOND"
    }
}
```

**Step 3: 发布API**
```java
// 发布API
POST /api/v1/apis/{apiId}/publish
{
    "publishNote": "首次发布"
}

// 内部处理流程：
1. 校验API配置完整性
2. 更新API状态为 PUBLISHED
3. 生成API版本快照
4. 发送 Kafka 事件: API_PUBLISHED
5. Gateway Service 消费事件，更新路由配置
6. 返回发布结果
```

**Step 4: 网关路由生效**
```java
// Gateway Service 消费 API_PUBLISHED 事件
@KafkaListener(topics = "api-events")
public void onApiPublished(ApiPublishedEvent event) {
    // 1. 获取API完整配置
    ApiConfig config = apiService.getApiConfig(event.getApiId());
    
    // 2. 构建路由规则
    RouteDefinition route = buildRouteDefinition(config);
    
    // 3. 动态更新网关路由
    gatewayRouteService.addRoute(route);
    
    // 4. 更新Redis缓存
    redisTemplate.opsForHash().put("api:routes", config.getPath(), route);
}
```

### 3.2 API调用流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           API 调用流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┐                                                      ┌──────────┐
│  客户端   │                                                      │ 后端服务  │
│ (APP)    │                                                      │          │
└────┬─────┘                                                      └────▲─────┘
     │                                                                 │
     │ 1. 请求 + AppKey/Token                                          │
     ▼                                                                 │
┌─────────────────────────────────────────────────────────────────────────────┐
│                         API Gateway (intellihub-gateway)                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐      │
│  │ 请求接收 │──▶│ 鉴权过滤 │──▶│ 限流过滤 │──▶│ 路由转发 │──▶│ 响应处理 │      │
│  │         │   │         │   │         │   │         │   │         │      │
│  │TraceId  │   │JWT校验  │   │Sentinel │   │负载均衡 │   │日志采集 │      │
│  │生成     │   │AppKey   │   │限流     │   │重试     │   │响应封装 │      │
│  │租户解析 │   │权限校验 │   │熔断     │   │超时控制 │   │异常处理 │      │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘      │
│       │             │             │             │             │            │
│       ▼             ▼             ▼             ▼             ▼            │
│  ┌─────────────────────────────────────────────────────────────────┐      │
│  │                        Redis 缓存层                              │      │
│  │  - Token缓存    - 路由配置    - 限流计数    - API元数据          │      │
│  └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
     │                                                                 │
     │ 2. 转发请求                                                     │
     └─────────────────────────────────────────────────────────────────┘
     │
     │ 3. 异步日志
     ▼
┌──────────┐         ┌──────────┐         ┌──────────┐
│  Kafka   │────────▶│ Monitor  │────────▶│   ES     │
│ 调用日志  │         │ Service  │         │ 日志存储  │
└──────────┘         └──────────┘         └──────────┘
```

#### 3.2.1 调用流程详细步骤

**Step 1: 请求接收与预处理**
```java
// Gateway GlobalFilter
@Component
public class RequestPreFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 1. 生成 TraceId
        String traceId = IdUtil.fastSimpleUUID();
        
        // 2. 解析租户信息（从Header或Token中）
        String tenantId = extractTenantId(request);
        
        // 3. 构建请求上下文
        RequestContext context = RequestContext.builder()
            .traceId(traceId)
            .tenantId(tenantId)
            .requestTime(System.currentTimeMillis())
            .clientIp(getClientIp(request))
            .build();
        
        // 4. 放入Exchange属性
        exchange.getAttributes().put("REQUEST_CONTEXT", context);
        
        // 5. 添加请求头
        ServerHttpRequest newRequest = request.mutate()
            .header("X-Trace-Id", traceId)
            .header("X-Tenant-Id", tenantId)
            .build();
        
        return chain.filter(exchange.mutate().request(newRequest).build());
    }
}
```

**Step 2: 鉴权过滤**
```java
// 鉴权过滤器
@Component
public class AuthFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().value();
        
        // 1. 获取API配置（从Redis缓存）
        ApiConfig apiConfig = getApiConfig(path);
        if (apiConfig == null) {
            return unauthorized(exchange, "API不存在");
        }
        
        // 2. 检查是否需要认证
        if (!apiConfig.isAuthRequired()) {
            return chain.filter(exchange);
        }
        
        // 3. JWT Token 认证
        String token = extractToken(request);
        if (StringUtils.hasText(token)) {
            TokenInfo tokenInfo = validateJwtToken(token);
            if (tokenInfo != null) {
                // 设置用户信息到上下文
                setUserContext(exchange, tokenInfo);
                return chain.filter(exchange);
            }
        }
        
        // 4. AppKey/Secret 认证
        String appKey = request.getHeaders().getFirst("X-App-Key");
        String signature = request.getHeaders().getFirst("X-Signature");
        String timestamp = request.getHeaders().getFirst("X-Timestamp");
        
        if (validateAppKeyAuth(appKey, signature, timestamp, request)) {
            AppInfo appInfo = getAppInfo(appKey);
            setAppContext(exchange, appInfo);
            return chain.filter(exchange);
        }
        
        return unauthorized(exchange, "认证失败");
    }
    
    // AppKey签名验证
    private boolean validateAppKeyAuth(String appKey, String signature, 
                                       String timestamp, ServerHttpRequest request) {
        // 1. 检查时间戳防重放（5分钟有效期）
        long ts = Long.parseLong(timestamp);
        if (Math.abs(System.currentTimeMillis() - ts) > 5 * 60 * 1000) {
            return false;
        }
        
        // 2. 获取AppSecret
        String appSecret = getAppSecret(appKey);
        if (appSecret == null) {
            return false;
        }
        
        // 3. 验证签名
        // 签名算法: HMAC-SHA256(appKey + timestamp + method + path + body, appSecret)
        String signContent = appKey + timestamp + request.getMethodValue() 
                           + request.getPath().value();
        String expectedSign = HmacUtils.hmacSha256Hex(appSecret, signContent);
        
        return expectedSign.equals(signature);
    }
}
```

**Step 3: 限流过滤**
```java
// 限流过滤器（基于Sentinel）
@Component
public class RateLimitFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        RequestContext context = exchange.getAttribute("REQUEST_CONTEXT");
        String path = exchange.getRequest().getPath().value();
        
        // 多维度限流资源
        // 1. API级别限流
        String apiResource = "api:" + path;
        
        // 2. 租户级别限流
        String tenantResource = "tenant:" + context.getTenantId();
        
        // 3. 应用级别限流
        String appResource = "app:" + context.getAppId();
        
        try {
            // Sentinel 限流检查
            Entry apiEntry = SphU.entry(apiResource);
            Entry tenantEntry = SphU.entry(tenantResource);
            Entry appEntry = SphU.entry(appResource);
            
            try {
                return chain.filter(exchange);
            } finally {
                apiEntry.exit();
                tenantEntry.exit();
                appEntry.exit();
            }
        } catch (BlockException e) {
            return rateLimitResponse(exchange, "请求过于频繁，请稍后重试");
        }
    }
}
```

**Step 4: 路由转发**
```java
// 动态路由配置
@Configuration
public class DynamicRouteConfig {
    
    @Autowired
    private RouteDefinitionRepository routeDefinitionRepository;
    
    // 从Redis加载路由配置
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("dynamic-route", r -> r
                .path("/api/**")
                .filters(f -> f
                    .stripPrefix(1)
                    .retry(config -> config
                        .setRetries(2)
                        .setStatuses(HttpStatus.INTERNAL_SERVER_ERROR))
                    .circuitBreaker(config -> config
                        .setName("backendCircuitBreaker")
                        .setFallbackUri("forward:/fallback")))
                .uri("lb://backend-service"))
            .build();
    }
}
```

**Step 5: 响应处理与日志采集**
```java
// 响应后置过滤器
@Component
public class ResponsePostFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            RequestContext context = exchange.getAttribute("REQUEST_CONTEXT");
            ServerHttpResponse response = exchange.getResponse();
            
            // 构建调用日志
            ApiCallLog callLog = ApiCallLog.builder()
                .traceId(context.getTraceId())
                .tenantId(context.getTenantId())
                .appId(context.getAppId())
                .userId(context.getUserId())
                .apiPath(exchange.getRequest().getPath().value())
                .method(exchange.getRequest().getMethodValue())
                .clientIp(context.getClientIp())
                .statusCode(response.getStatusCode().value())
                .latency(System.currentTimeMillis() - context.getRequestTime())
                .requestTime(new Date(context.getRequestTime()))
                .build();
            
            // 异步发送到Kafka
            kafkaTemplate.send("api-call-logs", JSON.toJSONString(callLog));
        }));
    }
}
```

### 3.3 服务间调用关系

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           服务间调用关系图                                    │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────────┐
                              │  Admin API      │
                              │  (聚合层)        │
                              └────────┬────────┘
                                       │
           ┌───────────────────────────┼───────────────────────────┐
           │                           │                           │
           ▼                           ▼                           ▼
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│   IAM Service   │◀───────▶│  API Service    │◀───────▶│Gateway Service  │
│                 │         │                 │         │                 │
│ - 用户认证      │         │ - API管理       │         │ - 路由配置      │
│ - 租户管理      │         │ - 文档生成      │         │ - 限流策略      │
│ - 权限校验      │         │ - 版本管理      │         │ - 插件管理      │
└────────┬────────┘         └────────┬────────┘         └────────┬────────┘
         │                           │                           │
         │                           │                           │
         └───────────────────────────┼───────────────────────────┘
                                     │
                                     ▼
                          ┌─────────────────┐
                          │ Monitor Service │
                          │                 │
                          │ - 调用统计      │
                          │ - 日志分析      │
                          │ - 告警管理      │
                          └─────────────────┘

调用方式：
─────────▶  同步调用 (OpenFeign)
- - - - -▶  异步消息 (Kafka)
```

#### 3.3.1 Feign客户端定义

```java
// IAM Service Feign Client
@FeignClient(name = "intellihub-iam", path = "/iam")
public interface IamFeignClient {
    
    @GetMapping("/users/{userId}")
    Result<UserDTO> getUserById(@PathVariable("userId") String userId);
    
    @GetMapping("/tenants/{tenantId}")
    Result<TenantDTO> getTenantById(@PathVariable("tenantId") String tenantId);
    
    @PostMapping("/auth/validate-token")
    Result<TokenInfo> validateToken(@RequestBody TokenValidateRequest request);
    
    @GetMapping("/apps/{appKey}")
    Result<AppDTO> getAppByKey(@PathVariable("appKey") String appKey);
}

// API Service Feign Client
@FeignClient(name = "intellihub-api-service", path = "/api-service")
public interface ApiFeignClient {
    
    @GetMapping("/apis/{apiId}")
    Result<ApiDTO> getApiById(@PathVariable("apiId") String apiId);
    
    @GetMapping("/apis/by-path")
    Result<ApiDTO> getApiByPath(@RequestParam("path") String path);
    
    @PostMapping("/apis/{apiId}/publish")
    Result<Void> publishApi(@PathVariable("apiId") String apiId, 
                            @RequestBody PublishRequest request);
}

// Gateway Service Feign Client
@FeignClient(name = "intellihub-gateway-service", path = "/gateway-service")
public interface GatewayFeignClient {
    
    @GetMapping("/routes")
    Result<List<RouteDTO>> getAllRoutes();
    
    @PostMapping("/routes")
    Result<Void> addRoute(@RequestBody RouteDTO route);
    
    @DeleteMapping("/routes/{routeId}")
    Result<Void> deleteRoute(@PathVariable("routeId") String routeId);
    
    @GetMapping("/rate-limits/{apiId}")
    Result<RateLimitConfig> getRateLimitConfig(@PathVariable("apiId") String apiId);
}
```

---

## 四、数据库设计

### 4.1 数据库分库策略

| 数据库 | 服务 | 主要表 |
|-------|------|-------|
| **intellihub_iam** | IAM Service | 用户、租户、角色、权限、应用 |
| **intellihub_api** | API Service | API定义、版本、参数、文档 |
| **intellihub_gateway** | Gateway Service | 路由、限流、插件配置 |
| **intellihub_monitor** | Monitor Service | 调用统计、告警规则 |

### 4.2 核心表结构

#### 4.2.1 租户表 (t_tenant)

```sql
CREATE TABLE `t_tenant` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `tenant_id` varchar(64) NOT NULL COMMENT '租户ID',
  `name` varchar(128) NOT NULL COMMENT '租户名称',
  `contact_name` varchar(64) DEFAULT NULL COMMENT '联系人',
  `contact_phone` varchar(32) DEFAULT NULL COMMENT '联系电话',
  `contact_email` varchar(128) DEFAULT NULL COMMENT '联系邮箱',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态: 1-正常 0-停用',
  `expire_at` datetime DEFAULT NULL COMMENT '到期时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `deleted` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='租户表';
```

#### 4.2.2 用户表 (t_user)

```sql
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL COMMENT '用户ID',
  `tenant_id` varchar(64) NOT NULL COMMENT '租户ID',
  `username` varchar(64) NOT NULL COMMENT '用户名',
  `password` varchar(128) NOT NULL COMMENT '密码(加密)',
  `nickname` varchar(64) DEFAULT NULL COMMENT '昵称',
  `email` varchar(128) DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(32) DEFAULT NULL COMMENT '手机号',
  `avatar` varchar(256) DEFAULT NULL COMMENT '头像URL',
  `role` varchar(32) NOT NULL COMMENT '角色: platform_admin/tenant_admin/api_developer/api_consumer',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态: 1-正常 0-禁用',
  `last_login_at` datetime DEFAULT NULL COMMENT '最后登录时间',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `deleted` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_id` (`user_id`),
  UNIQUE KEY `uk_tenant_username` (`tenant_id`, `username`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

#### 4.2.3 应用表 (t_application)

```sql
CREATE TABLE `t_application` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `app_id` varchar(64) NOT NULL COMMENT '应用ID',
  `tenant_id` varchar(64) NOT NULL COMMENT '租户ID',
  `name` varchar(128) NOT NULL COMMENT '应用名称',
  `description` varchar(500) DEFAULT NULL COMMENT '应用描述',
  `app_key` varchar(64) NOT NULL COMMENT 'AppKey',
  `app_secret` varchar(128) NOT NULL COMMENT 'AppSecret(加密存储)',
  `callback_url` varchar(256) DEFAULT NULL COMMENT '回调地址',
  `ip_whitelist` text COMMENT 'IP白名单(JSON数组)',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态: 1-正常 0-停用',
  `created_by` varchar(64) DEFAULT NULL COMMENT '创建人',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `deleted` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_app_id` (`app_id`),
  UNIQUE KEY `uk_app_key` (`app_key`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='应用表';
```

#### 4.2.4 API定义表 (t_api_definition)

```sql
CREATE TABLE `t_api_definition` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `api_id` varchar(64) NOT NULL COMMENT 'API ID',
  `tenant_id` varchar(64) NOT NULL COMMENT '租户ID',
  `group_id` varchar(64) DEFAULT NULL COMMENT '分组ID',
  `name` varchar(128) NOT NULL COMMENT 'API名称',
  `description` varchar(500) DEFAULT NULL COMMENT 'API描述',
  `version` varchar(32) NOT NULL DEFAULT 'v1.0' COMMENT '版本号',
  `method` varchar(16) NOT NULL COMMENT '请求方法: GET/POST/PUT/DELETE',
  `path` varchar(256) NOT NULL COMMENT '请求路径',
  `content_type` varchar(64) DEFAULT 'application/json' COMMENT 'Content-Type',
  `status` varchar(32) NOT NULL DEFAULT 'DRAFT' COMMENT '状态: DRAFT/PUBLISHED/OFFLINE/DEPRECATED',
  `auth_required` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否需要认证',
  `auth_methods` varchar(128) DEFAULT 'JWT' COMMENT '认证方式(逗号分隔)',
  `backend_service` varchar(128) DEFAULT NULL COMMENT '后端服务名',
  `backend_path` varchar(256) DEFAULT NULL COMMENT '后端路径',
  `timeout` int(11) NOT NULL DEFAULT '5000' COMMENT '超时时间(ms)',
  `retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '重试次数',
  `created_by` varchar(64) DEFAULT NULL COMMENT '创建人',
  `published_at` datetime DEFAULT NULL COMMENT '发布时间',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `deleted` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_api_id` (`api_id`),
  UNIQUE KEY `uk_tenant_path_method` (`tenant_id`, `path`, `method`),
  KEY `idx_tenant_id` (`tenant_id`),
  KEY `idx_group_id` (`group_id`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='API定义表';
```

#### 4.2.5 API参数表 (t_api_param)

```sql
CREATE TABLE `t_api_param` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `api_id` varchar(64) NOT NULL COMMENT 'API ID',
  `param_type` varchar(32) NOT NULL COMMENT '参数类型: QUERY/PATH/HEADER/BODY',
  `name` varchar(64) NOT NULL COMMENT '参数名',
  `data_type` varchar(32) NOT NULL DEFAULT 'string' COMMENT '数据类型',
  `required` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否必填',
  `description` varchar(256) DEFAULT NULL COMMENT '参数描述',
  `example` varchar(256) DEFAULT NULL COMMENT '示例值',
  `default_value` varchar(256) DEFAULT NULL COMMENT '默认值',
  `sort_order` int(11) NOT NULL DEFAULT '0' COMMENT '排序',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_api_id` (`api_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='API参数表';
```

#### 4.2.6 路由配置表 (t_route_config)

```sql
CREATE TABLE `t_route_config` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `route_id` varchar(64) NOT NULL COMMENT '路由ID',
  `api_id` varchar(64) NOT NULL COMMENT 'API ID',
  `predicates` text NOT NULL COMMENT '路由断言(JSON)',
  `filters` text COMMENT '过滤器配置(JSON)',
  `uri` varchar(256) NOT NULL COMMENT '目标URI',
  `order` int(11) NOT NULL DEFAULT '0' COMMENT '优先级',
  `enabled` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否启用',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_route_id` (`route_id`),
  KEY `idx_api_id` (`api_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='路由配置表';
```

#### 4.2.7 限流配置表 (t_rate_limit_config)

```sql
CREATE TABLE `t_rate_limit_config` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `config_id` varchar(64) NOT NULL COMMENT '配置ID',
  `resource_type` varchar(32) NOT NULL COMMENT '资源类型: API/TENANT/APP',
  `resource_id` varchar(64) NOT NULL COMMENT '资源ID',
  `limit_count` int(11) NOT NULL COMMENT '限流阈值',
  `time_window` int(11) NOT NULL COMMENT '时间窗口(秒)',
  `limit_strategy` varchar(32) NOT NULL DEFAULT 'REJECT' COMMENT '限流策略: REJECT/QUEUE',
  `enabled` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否启用',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_config_id` (`config_id`),
  UNIQUE KEY `uk_resource` (`resource_type`, `resource_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='限流配置表';
```

#### 4.2.8 API调用统计表 (t_api_call_stats)

```sql
CREATE TABLE `t_api_call_stats` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `api_id` varchar(64) NOT NULL COMMENT 'API ID',
  `tenant_id` varchar(64) NOT NULL COMMENT '租户ID',
  `stat_date` date NOT NULL COMMENT '统计日期',
  `stat_hour` tinyint(4) DEFAULT NULL COMMENT '统计小时(0-23)',
  `total_calls` bigint(20) NOT NULL DEFAULT '0' COMMENT '总调用次数',
  `success_calls` bigint(20) NOT NULL DEFAULT '0' COMMENT '成功次数',
  `fail_calls` bigint(20) NOT NULL DEFAULT '0' COMMENT '失败次数',
  `avg_latency` int(11) NOT NULL DEFAULT '0' COMMENT '平均响应时间(ms)',
  `max_latency` int(11) NOT NULL DEFAULT '0' COMMENT '最大响应时间(ms)',
  `min_latency` int(11) NOT NULL DEFAULT '0' COMMENT '最小响应时间(ms)',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_api_date_hour` (`api_id`, `stat_date`, `stat_hour`),
  KEY `idx_tenant_date` (`tenant_id`, `stat_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='API调用统计表';
```

---

## 五、安全设计

### 5.1 认证机制

#### 5.1.1 JWT Token 认证

```java
// Token 结构
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "user_123",           // 用户ID
    "tenant_id": "tenant_abc",   // 租户ID
    "username": "zhangsan",      // 用户名
    "role": "api_developer",     // 角色
    "iat": 1705312800,           // 签发时间
    "exp": 1705320000            // 过期时间
  },
  "signature": "..."
}

// Token 签发
@Service
public class TokenService {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    
    public String generateToken(User user) {
        Date now = new Date();
        Date expiry = new Date(now.getTime() + jwtExpiration * 1000);
        
        return Jwts.builder()
            .setSubject(user.getUserId())
            .claim("tenant_id", user.getTenantId())
            .claim("username", user.getUsername())
            .claim("role", user.getRole())
            .setIssuedAt(now)
            .setExpiration(expiry)
            .signWith(SignatureAlgorithm.HS256, jwtSecret)
            .compact();
    }
}
```

#### 5.1.2 AppKey/Secret 认证

```java
// 签名生成算法
public class SignatureUtils {
    
    /**
     * 生成请求签名
     * 签名内容: appKey + timestamp + method + path + bodyMd5
     * 签名算法: HMAC-SHA256
     */
    public static String generateSignature(String appKey, String appSecret,
                                           String timestamp, String method,
                                           String path, String body) {
        String bodyMd5 = StringUtils.hasText(body) ? DigestUtils.md5Hex(body) : "";
        String signContent = appKey + timestamp + method + path + bodyMd5;
        return HmacUtils.hmacSha256Hex(appSecret, signContent);
    }
    
    /**
     * 验证签名
     */
    public static boolean verifySignature(String appKey, String appSecret,
                                          String timestamp, String method,
                                          String path, String body,
                                          String signature) {
        String expectedSign = generateSignature(appKey, appSecret, timestamp, 
                                                method, path, body);
        return expectedSign.equals(signature);
    }
}
```

### 5.2 多租户数据隔离

```java
// 租户上下文
public class TenantContext {
    private static final ThreadLocal<String> TENANT_ID = new ThreadLocal<>();
    
    public static void setTenantId(String tenantId) {
        TENANT_ID.set(tenantId);
    }
    
    public static String getTenantId() {
        return TENANT_ID.get();
    }
    
    public static void clear() {
        TENANT_ID.remove();
    }
}

// MyBatis 租户拦截器
@Intercepts({
    @Signature(type = Executor.class, method = "query", 
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
    @Signature(type = Executor.class, method = "update", 
               args = {MappedStatement.class, Object.class})
})
public class TenantInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        String tenantId = TenantContext.getTenantId();
        if (StringUtils.hasText(tenantId)) {
            // 自动添加租户条件
            MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
            Object parameter = invocation.getArgs()[1];
            
            // 注入租户ID到参数
            if (parameter instanceof Map) {
                ((Map) parameter).put("tenantId", tenantId);
            }
        }
        return invocation.proceed();
    }
}
```

---

## 六、部署架构

### 6.1 部署拓扑

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              生产环境部署架构                                 │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────┐
                              │   DNS/CDN   │
                              └──────┬──────┘
                                     │
                              ┌──────▼──────┐
                              │    Nginx    │
                              │  (负载均衡)  │
                              └──────┬──────┘
                                     │
                    ┌────────────────┼────────────────┐
                    │                │                │
             ┌──────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
             │  Gateway-1  │  │  Gateway-2  │  │  Gateway-3  │
             │   (8080)    │  │   (8080)    │  │   (8080)    │
             └──────┬──────┘  └──────┬──────┘  └──────┬──────┘
                    │                │                │
                    └────────────────┼────────────────┘
                                     │
                              ┌──────▼──────┐
                              │    Nacos    │
                              │ (注册中心)   │
                              └──────┬──────┘
                                     │
     ┌───────────────┬───────────────┼───────────────┬───────────────┐
     │               │               │               │               │
┌────▼────┐   ┌────▼────┐   ┌────▼────┐   ┌────▼────┐   ┌────▼────┐
│IAM x2   │   │API x2   │   │GW x2    │   │Monitor  │   │Admin x2 │
│Service  │   │Service  │   │Service  │   │x2       │   │API      │
└────┬────┘   └────┬────┘   └────┬────┘   └────┬────┘   └────┬────┘
     │               │               │               │               │
     └───────────────┴───────────────┼───────────────┴───────────────┘
                                     │
              ┌──────────────────────┼──────────────────────┐
              │                      │                      │
       ┌──────▼──────┐        ┌──────▼──────┐        ┌──────▼──────┐
       │   MySQL     │        │    Redis    │        │    Kafka    │
       │  (主从)     │        │  (Cluster)  │        │  (Cluster)  │
       └─────────────┘        └─────────────┘        └─────────────┘
```

### 6.2 Docker Compose 配置示例

```yaml
version: '3.8'

services:
  # Nacos 注册中心
  nacos:
    image: nacos/nacos-server:v2.2.0
    environment:
      - MODE=standalone
      - SPRING_DATASOURCE_PLATFORM=mysql
      - MYSQL_SERVICE_HOST=mysql
      - MYSQL_SERVICE_DB_NAME=nacos
      - MYSQL_SERVICE_USER=root
      - MYSQL_SERVICE_PASSWORD=root123
    ports:
      - "8848:8848"
    depends_on:
      - mysql

  # MySQL
  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root123
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"

  # Redis
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

  # Kafka
  kafka:
    image: bitnami/kafka:2.8
    environment:
      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181
      - ALLOW_PLAINTEXT_LISTENER=yes
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"

  zookeeper:
    image: bitnami/zookeeper:3.7
    environment:
      - ALLOW_ANONYMOUS_LOGIN=yes
    ports:
      - "2181:2181"

  # Gateway
  intellihub-gateway:
    build: ./intellihub-gateway
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8080:8080"
    depends_on:
      - nacos
      - redis

  # IAM Service
  intellihub-iam:
    build: ./intellihub-iam
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8082:8082"
    depends_on:
      - nacos
      - mysql
      - redis

  # API Service
  intellihub-api-service:
    build: ./intellihub-api-service
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8083:8083"
    depends_on:
      - nacos
      - mysql
      - kafka

  # Gateway Service
  intellihub-gateway-service:
    build: ./intellihub-gateway-service
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8084:8084"
    depends_on:
      - nacos
      - mysql
      - redis

  # Monitor Service
  intellihub-monitor:
    build: ./intellihub-monitor
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8085:8085"
    depends_on:
      - nacos
      - kafka
      - elasticsearch

  # Admin API
  intellihub-admin-api:
    build: ./intellihub-admin-api
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - NACOS_SERVER_ADDR=nacos:8848
    ports:
      - "8081:8081"
    depends_on:
      - nacos

volumes:
  mysql_data:
```

---

## 七、开发规范

### 7.1 项目结构规范

```
intellihub-xxx-biz/
├── src/main/java/com/intellihub/xxx/
│   ├── XxxApplication.java          # 启动类
│   ├── config/                       # 配置类
│   ├── controller/                   # 控制器
│   ├── service/                      # 服务层
│   │   ├── XxxService.java          # 接口
│   │   └── impl/                    # 实现
│   ├── mapper/                       # MyBatis Mapper
│   ├── entity/                       # 实体类
│   ├── dto/                          # 数据传输对象
│   ├── vo/                           # 视图对象
│   ├── convert/                      # 对象转换器
│   ├── enums/                        # 枚举类
│   ├── exception/                    # 异常类
│   └── util/                         # 工具类
└── src/main/resources/
    ├── application.yml               # 配置文件
    ├── application-dev.yml           # 开发环境配置
    ├── application-prod.yml          # 生产环境配置
    ├── mapper/                       # MyBatis XML
    └── logback-spring.xml            # 日志配置
```

### 7.2 统一响应格式

```java
@Data
@Builder
public class Result<T> {
    private int code;           // 状态码: 0-成功, 其他-失败
    private String message;     // 消息
    private T data;             // 数据
    private String traceId;     // 追踪ID
    private long timestamp;     // 时间戳
    
    public static <T> Result<T> success(T data) {
        return Result.<T>builder()
            .code(0)
            .message("success")
            .data(data)
            .traceId(TraceContext.getTraceId())
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    public static <T> Result<T> error(int code, String message) {
        return Result.<T>builder()
            .code(code)
            .message(message)
            .traceId(TraceContext.getTraceId())
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

### 7.3 异常处理

```java
// 业务异常
public class BusinessException extends RuntimeException {
    private int code;
    private String message;
    
    public BusinessException(ErrorCode errorCode) {
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
    }
}

// 错误码枚举
public enum ErrorCode {
    SUCCESS(0, "成功"),
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未授权"),
    FORBIDDEN(403, "禁止访问"),
    NOT_FOUND(404, "资源不存在"),
    RATE_LIMITED(429, "请求过于频繁"),
    INTERNAL_ERROR(500, "服务器内部错误"),
    
    // 业务错误码 (1xxx)
    USER_NOT_FOUND(1001, "用户不存在"),
    USER_PASSWORD_ERROR(1002, "密码错误"),
    TENANT_DISABLED(1003, "租户已停用"),
    API_NOT_FOUND(1004, "API不存在"),
    API_ALREADY_PUBLISHED(1005, "API已发布"),
    APP_KEY_INVALID(1006, "AppKey无效");
    
    private int code;
    private String message;
}

// 全局异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        return Result.error(e.getCode(), e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public Result<?> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(500, "服务器内部错误");
    }
}
```

---

## 八、后续规划

### 8.1 一期功能（MVP）

- [x] 用户登录认证
- [x] 租户管理
- [x] API生命周期管理
- [x] 基础网关功能（鉴权、限流、路由）
- [x] 调用统计

### 8.2 二期功能

- [ ] AIGC智能分析
- [ ] 灰度发布
- [ ] 插件化扩展
- [ ] 完善的告警系统
- [ ] API版本管理

### 8.3 三期功能

- [ ] 多云部署支持
- [ ] 完整的DevOps集成
- [ ] 高级安全特性
- [ ] 行业解决方案模板
