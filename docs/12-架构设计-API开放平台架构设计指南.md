# API 开放平台架构设计指南

> 本文基于 IntelliHub API 管理平台开发实践，系统性地介绍企业级 API 开放平台的架构设计、核心概念和实现方案。

---

## 一、平台定位与核心概念

### 1.1 什么是 API 开放平台

API 开放平台是企业对外提供 API 服务的统一入口，其核心作用是将公司内部的微服务接口安全、可控地暴露给外部调用者。

```
                    ┌─────────────────────────────────────────────────┐
                    │              公司内部网络（不对外暴露）            │
                    │                                                 │
                    │   ┌─────────┐  ┌─────────┐  ┌─────────┐        │
                    │   │ 用户服务 │  │ 订单服务 │  │ 支付服务 │  ...   │
                    │   │ (内部API)│  │ (内部API)│  │ (内部API)│        │
                    │   └────┬────┘  └────┬────┘  └────┬────┘        │
                    │        └────────────┼────────────┘              │
                    │              ┌──────▼──────┐                    │
                    │              │  开放平台    │                    │
                    │              │ (API Gateway)│                    │
                    │              └──────┬──────┘                    │
                    └─────────────────────┼───────────────────────────┘
                                          │  公网（对外暴露）
                                          ▼
                              ┌───────────────────────┐
                              │    外部调用者/客户     │
                              └───────────────────────┘
```

### 1.2 核心工作流程

1. **内部开发者** 在公司内部开发微服务接口
2. **开发者** 将需要对外暴露的接口 **注册到开放平台**
3. **开放平台** 作为统一入口，对外暴露这些 API
4. **外部调用者** 通过开放平台的公网地址调用 API，平台再转发到内部服务

### 1.3 平台核心职责

| 职责 | 说明 |
|------|------|
| **API 注册与管理** | 开发者注册、配置、发布 API |
| **统一入口** | 所有外部请求都经过开放平台 |
| **安全控制** | 认证、鉴权、限流、防刷 |
| **流量治理** | 负载均衡、熔断、降级 |
| **监控统计** | 调用量、成功率、响应时间等 |

---

## 二、网关认证架构

### 2.1 双流量认证模型

开放平台需要处理两类不同的流量，采用不同的认证策略：

```
                        ┌─────────────────────────────────────┐
                        │            网关 (Gateway)            │
                        │                                     │
   管理后台请求 ────────►│  ReactiveAuthenticationFilter       │
   (JWT Token)          │  - 验证 JWT Token                   │
                        │  - 路由到管理服务                    │
                        │                                     │
   开放API请求 ─────────►│  OpenApiAuthenticationFilter        │
   (API Key)            │  - 验证 API Key / App Secret        │
                        │  - 限流、计费                        │
                        │  - 路由到后端服务                    │
                        └─────────────────────────────────────┘
```

### 2.2 路径区分策略

| 路径前缀 | 用途 | 认证方式 |
|---------|------|---------|
| `/api/iam/**` | IAM 管理接口 | JWT Token |
| `/api/v1/apis/**` | API 管理接口 | JWT Token |
| `/open/**` | 开放 API 调用 | API Key + Sign |

### 2.3 白名单机制

白名单是认证系统的必要组成部分。没有白名单会导致"死循环"：用户需要登录才能访问登录接口，但没登录就没有 Token。

**必须放入白名单的接口**：

| 接口类型 | 示例 | 原因 |
|---------|------|------|
| 登录/注册 | `/auth/login` | 用户还没有 Token |
| 验证码 | `/auth/captcha` | 登录前获取 |
| Token 刷新 | `/auth/refresh` | 用旧 Token 换新 Token |
| 公开资源 | `/public/**` | 不需要登录就能看 |
| 健康检查 | `/actuator/health` | 运维监控用 |

---

## 三、API 注册与路由机制

### 3.1 注册的是什么

开发者注册的是接口的 **元数据**（地址、参数、认证方式等），而不是把代码部署到平台。

```
开发者的服务（已存在）          开放平台（我们开发的）
┌─────────────────┐            ┌─────────────────┐
│  用户服务        │            │                 │
│  - /users/info  │ ◄──注册──  │  API管理后台     │
│  - /users/list  │   元数据    │  记录接口信息    │
│                 │            │  - 路径、方法    │
│  运行在:        │            │  - 后端地址      │
│  192.168.1.100  │            │  - 认证方式      │
└─────────────────┘            └─────────────────┘
```

### 3.2 路径映射原理

开发者在开放平台注册接口时填写的信息：

```
接口名称：获取用户信息
对外路径：/open/user/info        ← 外部调用者看到的路径
后端地址：http://192.168.1.100:8080/api/users/info  ← 真实的内部服务地址
请求方法：GET
认证方式：API Key
```

**外部客户不知道内部服务的真实地址**，只知道开放平台的地址。

### 3.3 完整调用流程

```
步骤1: 外部调用者发起请求
       GET https://open.company.com/open/user/info
       Header: X-Api-Key: abc123

步骤2: 请求到达开放平台网关
       网关的 OpenApiFilter 拦截请求

步骤3: 网关验证 API Key
       - 验证 abc123 是否有效
       - 检查该 Key 是否有权限调用 /open/user/info

步骤4: 网关查询 API 配置（直接查数据库）
       SELECT * FROM api_info WHERE path = '/open/user/info'

步骤5: 网关根据 backend_type 选择调用方式
       HTTP / Dubbo / gRPC

步骤6: 网关转发请求到内部微服务

步骤7: 内部微服务处理业务逻辑，返回结果

步骤8: 网关接收响应，返回给外部调用者
```

---

## 四、多协议后端支持

### 4.1 HTTP vs RPC 选型

| 维度 | HTTP | RPC (Dubbo/gRPC) |
|------|------|------------------|
| **通用性** | ✅ 任何语言/框架都支持 | ❌ 需要特定协议支持 |
| **接入成本** | ✅ 开发者无需改造 | ❌ 需要引入 SDK |
| **协议转换** | ✅ 无需转换 | ❌ 需要 HTTP → RPC 转换 |
| **性能** | 一般 | ✅ 更高（二进制协议） |
| **调试** | ✅ 容易 | ❌ 需要专门工具 |

**开放平台推荐 HTTP**：通用、简单、无侵入。

### 4.2 策略模式实现多协议

```
                    ┌─────────────────────────────────────────┐
                    │              开放平台网关                │
                    │                                         │
外部 HTTP 请求 ────►│  ┌─────────────────────────────────┐    │
                    │  │      协议转换层                  │    │
                    │  │                                 │    │
                    │  │  HTTP → HTTP  (直接转发)        │────┼──► HTTP 服务
                    │  │  HTTP → Dubbo (泛化调用)        │────┼──► Dubbo 服务
                    │  │  HTTP → gRPC  (Stub调用)        │────┼──► gRPC 服务
                    │  │                                 │    │
                    │  └─────────────────────────────────┘    │
                    └─────────────────────────────────────────┘
```

### 4.3 Dubbo 泛化调用

**普通调用** 需要依赖服务接口的 JAR 包，导致网关依赖爆炸。

**泛化调用** 不需要依赖接口 JAR 包，通过字符串动态调用：

```java
GenericService genericService = ...;

Object result = genericService.$invoke(
    "getUserById",                    // 方法名（字符串）
    new String[]{"java.lang.String"}, // 参数类型（字符串）
    new Object[]{"123"}               // 参数值
);
```

**优点**：
- 网关不依赖任何业务接口
- 业务服务随便改，网关不用动
- 通过配置动态调用任何服务

---

## 五、角色权限设计

### 5.1 推荐角色体系

```
┌─────────────────────────────────────────────────────────────┐
│                      平台层                                  │
│  ┌─────────────────┐                                        │
│  │  平台管理员      │  - 管理所有租户                        │
│  │  (Super Admin)  │  - 平台配置、系统监控                  │
│  └─────────────────┘                                        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────┼───────────────────────────────┐
│                      租户层  │                               │
│  ┌─────────────────┐       │                               │
│  │  租户管理员      │  - 管理本租户用户                      │
│  │  (Tenant Admin) │  - 分配角色权限、审批API申请           │
│  └─────────────────┘                                        │
│           │                                                 │
│     ┌─────┴─────┐                                          │
│     ▼           ▼                                          │
│  ┌──────────┐  ┌──────────┐                                │
│  │ API提供者 │  │ API消费者 │                                │
│  │(Provider)│  │(Consumer)│                                │
│  └──────────┘  └──────────┘                                │
│  - 注册API     - 浏览API市场                                │
│  - 配置API     - 申请调用权限                                │
│  - 发布API     - 获取API Key                                │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 核心角色说明

| 角色 | 职责 |
|------|------|
| **平台管理员** | 超级管理员，管理整个平台 |
| **租户管理员** | 租户内最高权限，管理本租户用户和权限 |
| **API 提供者** | 注册、配置、发布 API |
| **API 消费者** | 申请调用 API、获取 API Key |

**注意**：一个用户可以同时拥有多个角色（如既是提供者又是消费者）。

---

## 六、API 开放原则

### 6.1 判断标准

| 标准 | 适合开放 | 不适合开放 |
|------|---------|-----------|
| **安全性** | 不涉及敏感操作 | 涉及系统管理、删除数据 |
| **业务价值** | 对外部有价值 | 仅内部流程使用 |
| **稳定性** | 接口稳定、不常变动 | 频繁变更的内部接口 |
| **独立性** | 可独立调用 | 依赖内部上下文 |

### 6.2 典型可开放接口

| 场景 | 示例接口 | 说明 |
|------|---------|------|
| **电商平台** | 商品查询、订单创建、物流查询 | 给第三方卖家/ERP系统 |
| **支付平台** | 支付下单、退款、账单查询 | 给商户系统 |
| **地图服务** | 地理编码、路径规划、POI搜索 | 给各种APP |
| **短信平台** | 发送短信、查询余额 | 给企业系统 |
| **AI服务** | 文本识别、图像分析 | 给开发者 |

### 6.3 不适合开放的接口

- **管理类接口**：用户管理、租户管理、角色权限
- **危险操作**：DELETE 类接口、系统配置修改
- **内部运维**：健康检查、内部监控

---

## 七、架构总结

### 7.1 核心理解

| 问题 | 答案 |
|------|------|
| API 配置存在哪里？ | **开放平台的数据库**，不是微服务 |
| 谁查询 API 配置？ | **网关直接查数据库** |
| 微服务需要知道开放平台吗？ | **不需要**，微服务只管处理业务 |
| 调用类型在哪里判断？ | **网关**，根据数据库中的 backend_type |

### 7.2 分层职责

```
┌──────────────────────────────────────────────────────────────────┐
│                         开放平台网关                              │
│   - 统一入口、认证鉴权、限流熔断、监控统计                          │
│   - 查询 API 配置、选择调用策略、转发请求                          │
└──────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
         HTTP微服务       Dubbo微服务      gRPC微服务
         (纯业务逻辑)     (纯业务逻辑)     (纯业务逻辑)
```

**网关是"智能代理"**：知道所有 API 的配置，负责路由和安全。

**微服务是"纯业务服务"**：不关心开放平台的存在，专注业务处理。

---

## 八、技术选型建议

| 组件 | 推荐技术 | 说明 |
|------|---------|------|
| **网关** | Spring Cloud Gateway | 响应式、高性能 |
| **服务注册** | Nacos | 配置管理 + 服务发现 |
| **认证** | JWT + API Key | 管理后台 + 开放API |
| **限流** | Redis + Lua | 分布式限流 |
| **监控** | Prometheus + Grafana | 指标采集与可视化 |
| **日志** | ELK | 统一日志管理 |

---

*文档版本：v1.0*
*更新时间：2024-12-26*
*基于 IntelliHub API 管理平台开发实践整理*
