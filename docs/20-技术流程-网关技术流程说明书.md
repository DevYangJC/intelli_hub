# IntelliHub 网关技术流程说明书

> 本说明书基于 `intelli-gateway-service` 现有代码梳理网关的真实执行流程，目标是让你能按“文字解释 → Mermaid 图 → 代码文件”快速建立整体理解。

---

## 一、整体架构与职责边界

**你需要先记住两件事**：

1. 网关同时承载两类流量：
   - **管理后台流量**：走 **JWT**（`JwtAuthenticationFilter`）
   - **开放 API 流量**：走 **AppKey + 签名 + 防重放**（`AppKeyAuthenticationFilter`），并由网关根据“路由配置”动态转发（`OpenApiRouteFilter`）
2. 网关除了转发，还承担：限流、防重放、租户校验、日志与指标上报、统一异常返回。

```mermaid
graph TB
  Client[客户端/前端/第三方] --> Gateway[Spring Cloud Gateway]

  subgraph GatewayService[网关服务 intelli-gateway-service]
    Routes[Routes 路由规则<br/>application.yml] --> Filters[GlobalFilter 链]
    Filters --> Forward[转发/动态路由]
    Filters --> Log[访问日志/调用日志上报]
    Filters --> Protect[限流/租户校验/鉴权]
  end

  Gateway -->|管理后台请求| IAM[intelli-auth-iam-service]
  Gateway -->|平台管理接口| Platform[intelli-api-platform-service]
  Gateway -->|治理监控接口| Gov[intelli-governance-service]
  Gateway -->|AIGC| AIGC[intelli-aigc-service]
  Gateway -->|应用中心| AppCenter[intelli-app-center-service]

  Gateway --> Redis[(Redis)]
  Gateway --> Kafka[(Kafka)]
  Kafka -->|事件消费| Gov

```

**图解**：

- **Routes** 决定请求进入哪个“服务路由”（静态路由）或进入“开放 API 动态路由”。
- **Filters** 决定请求是否放行、是否需要认证、是否限流、是否补全租户与用户上下文。
- **Forward** 对于开放 API：由网关自己决定转发到 HTTP 服务还是 Dubbo 服务。

---

## 二、路由层（Routes）如何把请求分流

网关路由规则定义于：

- `intelli-gateway-service/src/main/resources/application.yml`

核心路由（节选逻辑）：

- `/api/auth/**,/api/iam/**` → `intelli-auth-iam-service`
- `/api/platform/**` → `intelli-api-platform-service`
- `/api/governance/**,/api/monitor/**` → `intelli-governance-service`
- `/open/**,/external/**` → `forward:/open`（占位路由，真正由 `OpenApiRouteFilter` 动态转发）

```mermaid
flowchart TD
  A[请求进入网关] --> B{Path 命中静态 routes?}
  B -->|命中 /api/...| C[StripPrefix 等 filters]
  C --> D[lb:// 下游服务]
  B -->|命中 /open/** /external/**| E[forward:/open 占位]
  E --> F[进入 GlobalFilter 链
OpenApiRouteMatchFilter 标记 isOpenApi]
  F --> G[OpenApiRouteFilter 动态转发]
```

**图解**：

- `/api/**` 这类是“平台内部微服务”路由；转发目标由 `lb://serviceName` 负责。
- `/open/**` 这类是“开放 API”路由；`forward:/open` 只是让请求落到网关自身处理，真正的后端由数据库/配置（通过 Dubbo 获取）决定。

---

## 三、过滤器链（GlobalFilter）执行顺序：全局主线

过滤器顺序由：

- `FilterOrderConfig`

定义（按执行先后）：

1. `CacheBodyFilter`（-200）：缓存请求 Body（解决后续重复读取问题）
2. `AccessLogFilter`（-100）：记录访问日志 + 在响应结束时触发上报
3. `OpenApiRouteMatchFilter`（-50）：标记是否开放 API，并把匹配的 `ApiRouteDTO` 放入 exchange attributes
4. `RateLimitFilter`（100）：限流（在认证之前执行，节省认证成本）
5. `GlobalTenantFilter`（500）：租户校验与租户头补全
6. `JwtAuthenticationFilter`（1000）：管理后台 JWT 认证（白名单跳过）
7. `AppKeyAuthenticationFilter`（1100）：开放 API AppKey + 签名 + 防重放 + 订阅校验
8. `OpenApiRouteFilter`（1200）：开放 API 动态转发（HTTP/Dubbo/Mock）

```mermaid
flowchart LR
  R[Request] --> F1[CacheBodyFilter]
  F1 --> F2[AccessLogFilter]
  F2 --> F3[OpenApiRouteMatchFilter]
  F3 --> F4[RateLimitFilter]
  F4 --> F5[GlobalTenantFilter]
  F5 --> F6[JwtAuthenticationFilter]
  F6 --> F7[AppKeyAuthenticationFilter]
  F7 --> F8[OpenApiRouteFilter]
  F8 --> S[下游服务或网关直接返回]
```

**图解**：

- “开放 API”与“管理后台”不是两条完全独立的链路，而是共享同一条 Filter 链，通过 **WhiteList + isOpenApi 标记**实现分流。
- **先限流再认证**，是典型的网关优化：无效请求不要浪费鉴权与下游资源。

---

## 四、请求 Body 缓存（CacheBodyFilter）：为什么必须最先做

对应代码：

- `CacheBodyFilter`

**核心问题**：在 WebFlux/Reactive 流里，请求 Body 是流式的，读取一次后就“消费掉”了。

**网关的需求**：

- Dubbo 泛化调用需要把 Body 解析为 `Map` 参数
- HTTP 转发可能需要把 Body 原样透传

```mermaid
sequenceDiagram
  participant Client
  participant GW as CacheBodyFilter
  participant Next as 后续过滤器

  Client->>GW: POST/PUT/PATCH with Body
  GW->>GW: join(request.body) 读取 DataBuffer
  GW->>GW: 缓存字符串到 exchange.attributes[gateway.cached.body]
  GW->>GW: 用 ServerHttpRequestDecorator 重建可重复读取的 Body
  GW->>Next: chain.filter(新 request)
```

**图解**：

- `CacheBodyFilter.ATTR_CACHED_BODY = gateway.cached.body` 是后续读取 Body 的唯一入口。

---

## 五、开放 API 路由匹配（OpenApiRouteMatchFilter）：先“知道你是谁”

对应代码：

- `OpenApiRouteMatchFilter`
- `OpenApiRouteService`

**它做两件事**：

1. 判断 path 是否属于开放 API：`/open/**`、`/external/**`
2. 若是：通过 `OpenApiRouteService.matchRoute(path, method)` 获取 `ApiRouteDTO` 并写入：
   - `gateway.api.isOpenApi`
   - `gateway.api.route`
   - `gateway.api.id`

```mermaid
flowchart TD
  A[请求 path] --> B{匹配 /open/** 或 /external/** ?}
  B -->|否| C[ATTR_IS_OPEN_API=false
继续链路]
  B -->|是| D[ATTR_IS_OPEN_API=true]
  D --> E[OpenApiRouteService.matchRoute]
  E --> F{本地缓存命中?}
  F -->|是| G[写入 ATTR_API_ROUTE/ATTR_API_ID]
  F -->|否| H[Dubbo 调用 api-platform
matchRouteByPath]
  H --> I[写入本地缓存 + attributes]
  G --> J[继续链路]
  I --> J
```

**图解**：

- `OpenApiRouteService` 的本地缓存是 `ConcurrentHashMap`，支持 `{id}` 这种路径参数匹配（通过 `AntPathMatcher`）。
- 当本地缓存未命中时，才会通过 Dubbo 调用平台服务匹配路由。

---

## 六、开放 API 鉴权（AppKeyAuthenticationFilter）：签名 + 防重放 + 订阅校验

对应代码：

- `AppKeyAuthenticationFilter`
- `AppKeyService`

### 6.1 鉴权入口与跳过逻辑

- 先看是否启用：`gateway.appkey.enabled`
- 优先读取 `ApiRouteDTO.authType`：
  - `none`：直接放行
  - `signature`（或其他）：执行 AppKey 流程

```mermaid
flowchart TD
  A[进入 AppKeyAuthenticationFilter] --> B{appkey.enabled?}
  B -->|否| Z[直接放行]
  B -->|是| C{exchange 中有 ApiRouteDTO ?}
  C -->|有| D{route.authType == none ?}
  D -->|是| Z
  D -->|否| E[执行AppKey认证]
  C -->|无| F{path 在 appkey.auth-paths ?}
  F -->|否| Z
  F -->|是| E
```

### 6.2 认证流程（你理解这张图就理解了开放 API 安全）

```mermaid
sequenceDiagram
  participant Client
  participant GW as AppKeyAuthenticationFilter
  participant Redis
  participant AppCenter as AppCenterDubboService

  Client->>GW: 请求(带 X-App-Key/X-Timestamp/X-Nonce/X-Signature)
  GW->>GW: 校验必填 Header
  GW->>GW: 校验 Timestamp 容差
  GW->>Redis: setIfAbsent(nonceKey, 1, TTL)
  Redis-->>GW: success/false
  alt Nonce 重复
    GW-->>Client: 401 请求已处理
  else Nonce 新
    GW->>Redis: get appkeyInfo cache
    alt 缓存命中
      Redis-->>GW: appKeyInfo
    else 缓存未命中
      GW->>AppCenter: Dubbo getAppKeyInfo(appKey)
      AppCenter-->>GW: AppKeyInfoDTO
      GW->>Redis: set cache
    end
    GW->>GW: 校验 app 状态/过期
    GW->>GW: SignatureUtil.verifySignature
    GW->>AppCenter: Dubbo checkSubscriptionByApiId(appId, apiId)
    AppCenter-->>GW: true/false
    alt 未订阅
      GW-->>Client: 403 未订阅
    else 已订阅
      GW->>GW: 注入 X-App-Id/X-App-Key/X-Tenant-Id 到下游
      GW-->>Client: 放行进入后续链路
    end
  end
```

**图解**：

- **防重放**：`nonceKey = RedisKeyConstants.buildNonceKey(appKey, nonce)`，使用 `setIfAbsent`。
- **签名算法**：`SignatureUtil.verifySignature(signature, method, path, timestamp, nonce, appSecret)`。
- **授权模型**：必须“订阅 API”才允许调用（通过 Dubbo 到应用中心校验）。

---

## 七、管理后台 JWT 认证（JwtAuthenticationFilter）：只做本地验签

对应代码：

- `JwtAuthenticationFilter`
- `JwtUtil`
- `WhiteListConfig`

**核心逻辑**：

- 如果 path 在白名单：跳过 JWT
- 否则读取 `Authorization: Bearer <token>`
- `JwtUtil.parseToken` 本地解析并校验 `tokenType=access`
- 将 `X-User-Id`、`X-Username`、`X-Tenant-Id`、`X-User-Roles` 注入请求头传递给下游服务

```mermaid
flowchart TD
  A[进入 JwtAuthenticationFilter] --> B{auth.enabled?}
  B -->|否| Z[放行]
  B -->|是| C{path 在 WhiteList?}
  C -->|是| Z
  C -->|否| D[读取 Authorization]
  D --> E{Bearer 格式正确?}
  E -->|否| F[401 缺少或格式错误]
  E -->|是| G[JwtUtil.parseToken]
  G --> H{tokenType==access 且未过期?}
  H -->|否| F
  H -->|是| I[注入用户头: X-User-Id/X-Username/X-Tenant-Id/X-User-Roles]
  I --> Z
```

**图解**：

- JWT 校验完全在网关本地完成，不调用 IAM 服务，性能更高。
- 白名单里包含 `/open/**`，意味着开放 API **不会走 JWT**，而是走 AppKey。

---

## 八、租户校验（GlobalTenantFilter）：租户不存在直接拦截

对应代码：

- `GlobalTenantFilter`

**关键点**：

- 白名单路径不做租户校验
- 若请求缺失 `X-Tenant-Id`，默认租户为 `default`
- 非 default 租户：先查 Redis 缓存，不命中则 Dubbo 调用 `TenantDubboService.isValidTenant`

```mermaid
sequenceDiagram
  participant Req as Request
  participant GT as GlobalTenantFilter
  participant Redis
  participant TenantSvc as TenantDubboService

  Req->>GT: path + X-Tenant-Id
  GT->>GT: 白名单? 是则跳过
  GT->>GT: tenantId 缺失? -> default
  alt tenantId == default
    GT-->>Req: 放行并补全头
  else 非默认
    GT->>Redis: get tenantValidKey
    alt 缓存命中
      Redis-->>GT: 1/0
    else 缓存未命中
      GT->>TenantSvc: Dubbo isValidTenant
      TenantSvc-->>GT: true/false
      GT->>Redis: set tenantValidKey + TTL
    end
    alt 无效租户
      GT-->>Req: 403
    else 有效
      GT-->>Req: 放行并补全头
    end
  end
```

**图解**：

- 这个过滤器让“租户非法”在网关层直接失败，避免下游服务各自重复校验。

---

## 九、限流（RateLimitFilter + RateLimitService）：三维度组合限流

对应代码：

- `RateLimitFilter`
- `RateLimitConfig`
- `RateLimitService`

**限流维度**（当前实现）：

- IP 维度（更宽松）
- Path 维度（更宽松）
- IP+Path 组合（最严格）

```mermaid
flowchart TD
  A[进入 RateLimitFilter] --> B{rate-limit.enabled?}
  B -->|否| Z[放行]
  B -->|是| C[解析 IP + path]
  C --> D[选择 limit 配置: 优先匹配 specific limits，否则 default]
  D --> E[检查 IP 维度 isAllowed]
  E -->|否| R[429 IP级别限流]
  E -->|是| F[检查 Path 维度 isAllowed]
  F -->|否| R
  F -->|是| G[检查 IP+Path 维度 isAllowed]
  G -->|否| R
  G -->|是| Z
```

**图解**：

- 限流在认证之前执行：无效请求不用走签名/JWT 校验。
- 目前 `RateLimitService.isAllowed` 是“固定窗口计数”风格；配置里虽然有算法枚举，但实际 Filter 调用的是 `isAllowed`（可后续升级为滑动窗口/令牌桶）。

---

## 十、开放 API 动态转发（OpenApiRouteFilter）：HTTP / Dubbo / Mock

对应代码：

- `OpenApiRouteFilter`
- `DubboGenericService`

### 10.1 总体转发决策

```mermaid
flowchart TD
  A[进入 OpenApiRouteFilter] --> B{ATTR_IS_OPEN_API==true ?}
  B -->|否| Z[放行（不是开放API）]
  B -->|是| C[从 attributes 取 ApiRouteDTO]
  C --> D{route 为空?}
  D -->|是| N[404 API不存在或未发布]
  D -->|否| E{mockEnabled?}
  E -->|是| M[直接返回 mockResponse]
  E -->|否| F{backendType}
  F -->|http| H[WebClient 转发到HTTP后端]
  F -->|dubbo| J[DubboGenericService.$invoke]
  F -->|其他| X[500 后端配置错误]
```

### 10.2 HTTP 后端转发：服务名解析 + WebClient 透传

```mermaid
sequenceDiagram
  participant Client
  participant GW as OpenApiRouteFilter
  participant LB as LoadBalancerClient
  participant Backend as HTTP Backend

  Client->>GW: /open/... 请求
  GW->>GW: resolveBackendUri(route)
  alt backendHost 是服务名
    GW->>LB: choose(serviceName)
    LB-->>GW: ServiceInstance(uri)
  end
  GW->>Backend: WebClient(method, url)
  Backend-->>GW: Response body
  GW-->>Client: 200 + body
```

**图解**：

- `resolveBackendUri` 会把 `backendHost` 当作“服务名”处理（不是 IP 且不含端口）。
- 请求头会复制（排除 Host），Body 通过 `CacheBodyFilter` 的缓存值透传。

### 10.3 Dubbo 后端转发：参数提取 + 泛化调用

```mermaid
sequenceDiagram
  participant Client
  participant GW as OpenApiRouteFilter
  participant Cache as CacheBodyFilter
  participant Dubbo as DubboGenericService
  participant Provider as Dubbo Provider

  Client->>GW: /open/... POST/GET
  GW->>GW: 提取 queryParams
  GW->>Cache: 读取 cachedBody(JSON)
  GW->>GW: 合并为 Map params
  GW->>Dubbo: invoke(route, params)
  Dubbo->>Provider: GenericService.$invoke
  Provider-->>Dubbo: result(Object/Map)
  Dubbo-->>GW: result
  GW-->>Client: ApiResponse.success(result)
```

**图解**：

- Dubbo 泛化调用的关键是：网关不依赖业务接口 Jar。
- `DubboGenericService` 内部缓存 `GenericService`，减少每次创建开销。

---

## 十一、访问日志与调用日志上报（AccessLogFilter + CallLogReportService）

对应代码：

- `AccessLogFilter`
- `CallLogReportService`

### 11.1 记录访问日志（开始/结束）

`AccessLogFilter` 在请求开始记录一次日志，在 `chain.filter(exchange).then(...)` 中记录结束耗时并触发上报。

```mermaid
sequenceDiagram
  participant Req
  participant Log as AccessLogFilter
  participant Chain as GatewayFilterChain

  Req->>Log: request
  Log->>Log: 记录 startTime/method/uri/ip
  Log->>Chain: chain.filter
  Chain-->>Log: 响应完成
  Log->>Log: 记录 statusCode/duration
  Log->>Log: 调用 CallLogReportService.reportCallLog
```

### 11.2 上报到 Kafka + 更新 Redis 实时统计

```mermaid
flowchart TD
    A[reportCallLog] --> B[构建 logData Map]
    B --> C["Kafka producer send -> topic CALL_LOG"]
    B --> D[updateRealtimeStats]
    D --> E["RPUSH alert:requests:{tenant}:{hour}"]
    D --> F["HINCRBY alert:stats:{tenant}:{hour}"]
    D --> G["INCR alert:qps:{tenant}:{minute}"]

```

**图解**：

- Kafka 用于治理服务异步消费（日志落库、统计报表）。
- Redis 用于告警系统的实时检测与短周期指标计算。

---

## 十二、异常处理（GatewayExceptionHandler）：统一错误返回

对应代码：

- `GatewayExceptionHandler`（实现 `ErrorWebExceptionHandler`）

```mermaid
flowchart TD
  A[网关内发生异常] --> B{response 已提交?}
  B -->|是| C[直接抛出]
  B -->|否| D[设置 Content-Type=application/json]
  D --> E{异常类型}
  E -->|ResponseStatusException| F[按状态码映射提示
404/502/504/429...]
  E -->|ConnectTimeoutException| G[504 连接下游超时]
  E -->|PrematureCloseException| H[502 下游连接异常关闭]
  E -->|invalid version format| I[400 无效请求格式]
  E -->|其他| J[500 网关异常]
  F --> K[写出 ApiResponse.failed]
  G --> K
  H --> K
  I --> K
  J --> K
```

**图解**：

- 这个处理器保证网关在多数异常情况下都返回统一 JSON 结构（`ApiResponse`）。

---

## 十三、配置清单（关键开关与含义）

主要配置来源：

- `application.yml`（本地默认）
- `optional:nacos:intelli-gateway-service.yml`（可覆盖）

关键配置项：

- `spring.cloud.gateway.routes`：静态路由与 open-api 占位路由
- `intellihub.gateway.auth.enabled`：JWT 认证开关
- `intellihub.gateway.whitelist.paths`：JWT/租户校验白名单（包含 open api）
- `intellihub.gateway.rate-limit.enabled`：限流开关
- `gateway.appkey.enabled`：开放 API AppKey 认证开关

---

## 十四、按“现有代码”理解的两条主路径总结

### 14.1 管理后台请求路径（JWT）

```mermaid
flowchart TD
    A["/api/... 管理接口"] --> B[RateLimitFilter]
    B --> C[GlobalTenantFilter]
    C --> D[JwtAuthenticationFilter]
    D --> E["lb://下游服务"]
    E --> F["AccessLogFilter\n上报 Kafka + Redis"]

```

### 14.2 开放 API 请求路径（AppKey + 动态路由）

```mermaid
flowchart TD
    A["/open/** 开放API"] --> B[OpenApiRouteMatchFilter\n匹配 ApiRouteDTO]
    B --> C[RateLimitFilter]
    C --> D[GlobalTenantFilter]
    D --> E[AppKeyAuthenticationFilter\n签名/防重放/订阅]
    E --> F[OpenApiRouteFilter\nHTTP/Dubbo/Mock]
    F --> G[返回响应]
    G --> H["AccessLogFilter\n上报 Kafka + Redis"]

```

---

## 附录：关键文件速查（从图到代码）

| 领域 | 文件 |
|------|------|
| 路由配置 | `intelli-gateway-service/src/main/resources/application.yml` |
| 过滤器顺序 | `FilterOrderConfig` |
| Body 缓存 | `CacheBodyFilter` |
| 开放API匹配 | `OpenApiRouteMatchFilter`, `OpenApiRouteService` |
| AppKey认证 | `AppKeyAuthenticationFilter`, `AppKeyService` |
| JWT认证 | `JwtAuthenticationFilter`, `JwtUtil`, `WhiteListConfig`, `JwtConfig` |
| 租户校验 | `GlobalTenantFilter` |
| 限流 | `RateLimitFilter`, `RateLimitConfig`, `RateLimitService` |
| 动态路由转发 | `OpenApiRouteFilter`, `DubboGenericService` |
| 访问日志/上报 | `AccessLogFilter`, `CallLogReportService` |
| 全局异常 | `GatewayExceptionHandler` |
